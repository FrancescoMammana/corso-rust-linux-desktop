<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Progetto: Client HTTP | Corso Rust Linux Desktop</title>
    <style>* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: #1a1a1a;
    color: #e0e0e0;
    line-height: 1.6;
}

header {
    background: #2a2a2a;
    padding: 1rem 2rem;
    border-bottom: 3px solid #DE8E43;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 1000;
}

.header-content {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.rust-logo {
    font-size: 2rem;
    color: #DE8E43;
}

h1 {
    font-size: 1.5rem;
    color: #DE8E43;
}

.container {
    display: flex;
    margin-top: 70px;
    min-height: calc(100vh - 70px);
}

.sidebar {
    width: 280px;
    background: #252525;
    padding: 2rem 0;
    position: fixed;
    left: 0;
    height: calc(100vh - 70px);
    overflow-y: auto;
    border-right: 1px solid #3a3a3a;
}

.sidebar h3 {
    color: #DE8E43;
    padding: 0.5rem 1.5rem;
    font-size: 0.9rem;
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-top: 1rem;
}

.sidebar ul {
    list-style: none;
}

.sidebar li a {
    display: block;
    padding: 0.7rem 1.5rem 0.7rem 2.5rem;
    color: #b0b0b0;
    text-decoration: none;
    transition: all 0.3s;
    font-size: 0.95rem;
}

.sidebar li a:hover {
    background: #2f2f2f;
    color: #DE8E43;
    border-left: 3px solid #DE8E43;
}

.sidebar li a.active {
    background: #2f2f2f;
    color: #DE8E43;
    border-left: 3px solid #DE8E43;
    font-weight: 600;
}

.content {
    flex: 1;
    margin-left: 280px;
    padding: 2rem 3rem;
    max-width: 1200px;
}

.breadcrumb {
    color: #888;
    font-size: 0.9rem;
    margin-bottom: 2rem;
}

.breadcrumb a {
    color: #4A90E2;
    text-decoration: none;
}

.breadcrumb a:hover {
    text-decoration: underline;
}

.lesson-title {
    font-size: 2.5rem;
    color: #DE8E43;
    margin-bottom: 1rem;
}

.box {
    margin: 2rem 0;
    padding: 1.5rem;
    border-radius: 8px;
    border-left: 4px solid;
}

.box-theory {
    background: #2a2a3e;
    border-left-color: #4A90E2;
}

.box-steps {
    background: #2a2a2a;
    border-left-color: #DE8E43;
}

.box-code {
    background: #1e1e1e;
    border-left-color: #DE8E43;
    position: relative;
}

.box-exercises {
    background: #2d4a2e;
    border-left-color: #5cb85c;
}

.box-troubleshooting {
    background: #4a2d2e;
    border-left-color: #d9534f;
}

.box h3 {
    color: #DE8E43;
    margin-bottom: 1rem;
    font-size: 1.3rem;
}

.box-theory h3 { color: #4A90E2; }
.box-exercises h3 { color: #5cb85c; }
.box-troubleshooting h3 { color: #d9534f; }

code {
    font-family: 'Fira Code', 'Courier New', monospace;
    background: #2a2a2a;
    padding: 0.2rem 0.4rem;
    border-radius: 3px;
    font-size: 0.9rem;
    color: #DE8E43;
}

pre {
    background: #1e1e1e;
    padding: 1.5rem;
    border-radius: 5px;
    overflow-x: auto;
    margin: 1rem 0;
}

pre code {
    background: none;
    padding: 0;
    color: #e0e0e0;
    display: block;
}

.copy-button {
    position: absolute;
    top: 1rem;
    right: 1rem;
    background: #DE8E43;
    color: #1a1a1a;
    border: none;
    padding: 0.4rem 0.8rem;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.85rem;
    font-weight: 600;
}

.copy-button:hover {
    background: #f09d5a;
}

ol, ul {
    margin-left: 1.5rem;
    margin-top: 0.5rem;
}

li {
    margin: 0.5rem 0;
}

.lesson-nav {
    display: flex;
    justify-content: space-between;
    margin-top: 3rem;
    padding-top: 2rem;
    border-top: 1px solid #3a3a3a;
}

.lesson-nav a {
    background: #DE8E43;
    color: #1a1a1a;
    padding: 0.8rem 1.5rem;
    border-radius: 5px;
    text-decoration: none;
    font-weight: 600;
    transition: all 0.3s;
}

.lesson-nav a:hover {
    background: #f09d5a;
    transform: translateY(-2px);
}

.lesson-nav a.disabled {
    background: #3a3a3a;
    color: #666;
    cursor: not-allowed;
}

footer {
    background: #252525;
    padding: 2rem;
    text-align: center;
    color: #888;
    border-top: 1px solid #3a3a3a;
    margin-top: 3rem;
}

@media (max-width: 768px) {
    .sidebar {
        transform: translateX(-100%);
        transition: transform 0.3s;
    }

    .sidebar.open {
        transform: translateX(0);
    }

    .content {
        margin-left: 0;
        padding: 1rem;
    }
}</style>
</head>
<body>
    <header>
        <div class="header-content">
            <div class="rust-logo">ü¶Ä</div>
            <h1>Corso Completo: Sviluppo Applicazioni Desktop Linux in Rust</h1>
        </div>
    </header>
    <div class="container">
        <aside class="sidebar">
        <h3>üìö Corso Rust Linux</h3>
        <ul><li><a href="index.html">üè† Home</a></li></ul>
        <h3>1. Ambiente di Sviluppo</h3>
        <ul><li><a href="lesson-1-1.html">1.1 Installazione Rust</a></li>
<li><a href="lesson-1-2.html">1.2 Config VS Code</a></li>
<li><a href="lesson-1-3.html">1.3 Strumenti Extra</a></li></ul>
        <h3>2. Rust Base</h3>
        <ul><li><a href="lesson-2-1.html">2.1 Sintassi Fondamentale</a></li>
<li><a href="lesson-2-2.html">2.2 Strutture Controllo</a></li>
<li><a href="lesson-2-3.html">2.3 Struttura Progetto</a></li>
<li><a href="lesson-2-4.html">2.4 Crate & Dipendenze</a></li></ul>
        <h3>3. Sviluppo GUI</h3>
        <ul><li><a href="lesson-3-1.html">3.1 Intro GTK-rs</a></li>
<li><a href="lesson-3-2.html">3.2 Glade Designer</a></li>
<li><a href="lesson-3-3.html">3.3 Sviluppo Manuale</a></li>
<li><a href="lesson-3-4.html">3.4 Widget & Eventi</a></li>
<li><a href="lesson-3-5.html">3.5 Menu & Dialog</a></li></ul>
        <h3>4. Progetti Pratici</h3>
        <ul><li><a href="lesson-4-1.html">4.1 Editor di Testo</a></li>
<li><a href="lesson-4-2.html">4.2 Gestore Note DB</a></li>
<li><a href="lesson-4-3.html">4.3 Client HTTP</a></li></ul>
        <h3>5. GitHub & Best Practices</h3>
        <ul><li><a href="lesson-5-1.html">5.1 Repository GitHub</a></li>
<li><a href="lesson-5-2.html">5.2 Documentazione</a></li>
<li><a href="lesson-5-3.html">5.3 Testing & Debug</a></li></ul>
        <h3>üìñ Altro</h3>
        <ul><li><a href="about.html">‚ÑπÔ∏è Info Corso</a></li>
<li><a href="projects.html">üéØ Progetti</a></li>
<li><a href="resources.html">üîó Risorse</a></li>
<li><a href="faq.html">‚ùì FAQ</a></li></ul>
    </aside>
        <main class="content">
            <nav class="breadcrumb">
                <a href="index.html">Home</a> > Sezione 4: Progetti Pratici > Progetto: Client HTTP
            </nav>
            <h2 class="lesson-title">Progetto: Client HTTP</h2>
            <div class="box box-theory">
                <h3>üìò Introduzione Teorica</h3>
                
<p>Un <strong>client HTTP</strong> con interfaccia GUI dimostra programmazione asincrona e networking in Rust:</p>
<ul>
    <li><strong>async/await</strong>: Programmazione asincrona non-blocking</li>
    <li><strong>tokio runtime</strong>: Executor per task async</li>
    <li><strong>reqwest</strong>: HTTP client moderno e ergonomico</li>
    <li><strong>Progress tracking</strong>: Mostra avanzamento download</li>
    <li><strong>Error handling</strong>: Gestione timeout, rete, parsing</li>
    <li><strong>GTK integration</strong>: Aggiorna UI dai task async</li>
    <li><strong>JSON parsing</strong>: Deserializzazione risposta API</li>
</ul>
<p>Questo progetto integra concetti avanzati di Rust: ownership, async, networking e GTK.</p>

            </div>
            <div class="box box-steps">
                <h3>üîß Procedura Passo-Passo</h3>
                
<ol>
    <li><strong>Aggiungi dipendenze</strong>
        <pre><code>[dependencies]
gtk = { version = "0.18", features = ["v3_24"] }
tokio = { version = "1", features = ["full"] }
reqwest = { version = "0.11", features = ["json"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"</code></pre>
    </li>

    <li><strong>Setup tokio runtime</strong>
        <pre><code>use tokio::runtime::Runtime;

let runtime = Runtime::new().unwrap();

// In callback:
runtime.spawn(async {
    // codice async
});</code></pre>
    </li>

    <li><strong>Creazione UI</strong>
        <pre><code>// Entry per URL
// Label per status
// ProgressBar per download
// TextView per risultato
// Button "Scarica"</code></pre>
    </li>

    <li><strong>GET request asincrono</strong>
        <pre><code>async fn fetch_url(url: &str) -> Result<String, Box<dyn std::error::Error>> {
    let response = reqwest::get(url).await?;
    let body = response.text().await?;
    Ok(body)
}</code></pre>
    </li>

    <li><strong>Download con progress</strong>
        <pre><code>async fn download_file(url: &str, path: &str) -> Result<()> {
    let response = reqwest::get(url).await?;
    let total_size = response.content_length().unwrap_or(0);
    let mut downloaded = 0u64;

    // Streama e aggiorna progressbar
}</code></pre>
    </li>
</ol>

            </div>
            <div class="box box-code">
                <h3>üíª Codice Sorgente Commentato</h3>
                <button class="copy-button">Copia</button>
                
<pre><code>// ========================================
// PROGETTO: HTTP CLIENT CON DOWNLOAD
// 350+ righe commentate
// ========================================

use gtk::prelude::*;
use gtk::{Application, ApplicationWindow, Box, Button, Entry, Label, ProgressBar,
          TextView, Orientation, ScrolledWindow, Adjustment};
use glib::clone;
use std::sync::{Arc, Mutex};
use tokio::runtime::Runtime;

fn main() {
    let app = Application::builder()
        .application_id("com.example.HttpClient")
        .build();

    app.connect_activate(build_ui);
    app.run();
}

fn build_ui(app: &Application) {
    let window = ApplicationWindow::builder()
        .application(app)
        .title("HTTP Client")
        .default_width(800)
        .default_height(600)
        .build();

    let vbox = Box::new(Orientation::Vertical, 10);
    vbox.set_border_width(10);

    // ========================================
    // INPUT SECTION
    // ========================================
    let input_box = Box::new(Orientation::Horizontal, 5);

    let url_label = Label::new(Some("URL:"));
    let url_entry = Entry::new();
    url_entry.set_placeholder_text(Some("https://api.github.com/users/rust-lang"));

    input_box.pack_start(&url_label, false, false, 0);
    input_box.pack_start(&url_entry, true, true, 0);

    vbox.pack_start(&input_box, false, false, 0);

    // ========================================
    // BUTTONS
    // ========================================
    let button_box = Box::new(Orientation::Horizontal, 5);

    let fetch_btn = Button::with_label("üåê Fetch");
    let save_btn = Button::with_label("üíæ Salva");
    let clear_btn = Button::with_label("üóëÔ∏è Pulisci");

    button_box.pack_start(&fetch_btn, false, false, 0);
    button_box.pack_start(&save_btn, false, false, 0);
    button_box.pack_start(&clear_btn, false, false, 0);

    vbox.pack_start(&button_box, false, false, 0);

    // ========================================
    // PROGRESS BAR
    // ========================================
    let progress_bar = ProgressBar::new();
    progress_bar.set_fraction(0.0);
    vbox.pack_start(&progress_bar, false, false, 0);

    // ========================================
    // STATUS LABEL
    // ========================================
    let status_label = Label::new(Some("Pronto"));
    status_label.set_xalign(0.0);
    vbox.pack_start(&status_label, false, false, 0);

    // ========================================
    // RESPONSE TEXTVIEW
    // ========================================
    let response_label = Label::new(Some("Risposta:"));
    response_label.set_xalign(0.0);
    vbox.pack_start(&response_label, false, false, 0);

    let response_textview = TextView::new();
    response_textview.set_editable(false);
    response_textview.set_wrap_mode(gtk::WrapMode::WordChar);

    let scrolled = ScrolledWindow::new(None::<&Adjustment>, None::<&Adjustment>);
    scrolled.add(&response_textview);

    vbox.pack_start(&scrolled, true, true, 0);

    // ========================================
    // TOKIO RUNTIME
    // ========================================
    let runtime = Arc::new(Runtime::new().unwrap());

    // ========================================
    // BUTTON: FETCH
    // ========================================
    fetch_btn.connect_clicked(clone!(@weak url_entry, @weak progress_bar, @weak status_label, 
                                     @weak response_textview, @strong runtime => move |_| {
        let url = url_entry.text().to_string();

        if url.is_empty() {
            status_label.set_text("Errore: URL vuoto!");
            return;
        }

        status_label.set_text("‚è≥ Caricamento...");
        progress_bar.set_fraction(0.0);

        let response_clone = response_textview.clone();
        let status_clone = status_label.clone();
        let progress_clone = progress_bar.clone();

        // Spawn task asincrono
        runtime.spawn(async move {
            match fetch_url(&url).await {
                Ok(body) => {
                    glib::idle_add_local(move || {
                        response_clone.buffer().unwrap().set_text(&body);
                        progress_clone.set_fraction(1.0);
                        status_clone.set_text("‚úÖ Completato!");
                        glib::Continue(false)
                    });
                }
                Err(e) => {
                    let error_msg = format!("‚ùå Errore: {}", e);
                    glib::idle_add_local(move || {
                        status_clone.set_text(&error_msg);
                        progress_clone.set_fraction(0.0);
                        glib::Continue(false)
                    });
                }
            }
        });
    }));

    // ========================================
    // BUTTON: CLEAR
    // ========================================
    clear_btn.connect_clicked(clone!(@weak response_textview, @weak progress_bar, @weak status_label => move |_| {
        response_textview.buffer().unwrap().set_text("");
        progress_bar.set_fraction(0.0);
        status_label.set_text("Pulito");
    }));

    // ========================================
    // BUTTON: SAVE
    // ========================================
    save_btn.connect_clicked(clone!(@weak response_textview => move |_| {
        let buffer = response_textview.buffer().unwrap();
        let text = buffer.text(&buffer.start_iter(), &buffer.end_iter(), false);

        if let Err(e) = std::fs::write("response.json", text.to_string()) {
            println!("Errore salvataggio: {}", e);
        } else {
            println!("‚úÖ Salvato in response.json");
        }
    }));

    window.add(&vbox);
    window.show_all();
}

// ========================================
// FUNZIONI ASYNC
// ========================================

async fn fetch_url(url: &str) -> Result<String, Box<dyn std::error::Error>> {
    let client = reqwest::Client::new();

    let response = client.get(url)
        .timeout(std::time::Duration::from_secs(10))
        .send()
        .await?;

    if !response.status().is_success() {
        return Err(format!("HTTP {}", response.status()).into());
    }

    let body = response.text().await?;

    // Formatta JSON se possibile
    match serde_json::from_str::<serde_json::Value>(&body) {
        Ok(json) => Ok(serde_json::to_string_pretty(&json)?),
        Err(_) => Ok(body),
    }
}

// ========================================
// ESEMPIO: Deserializzare risposta
// ========================================

use serde::{Deserialize};

#[derive(Deserialize, Debug)]
struct GitHubUser {
    login: String,
    name: Option<String>,
    company: Option<String>,
    public_repos: u32,
    followers: u32,
}

async fn fetch_github_user(username: &str) -> Result<GitHubUser, Box<dyn std::error::Error>> {
    let url = format!("https://api.github.com/users/{}", username);
    let response = reqwest::get(&url).await?;
    let user = response.json::<GitHubUser>().await?;
    Ok(user)
}

// ========================================
// EXAMPLE: Download con Progress
// ========================================

async fn download_file(url: &str, dest_path: &str) -> Result<(), Box<dyn std::error::Error>> {
    let response = reqwest::get(url).await?;

    let total_size = response.content_length().unwrap_or(0);
    let mut downloaded = 0u64;
    let mut stream = response.bytes_stream();

    use futures::StreamExt;
    use tokio::fs::File;
    use tokio::io::AsyncWriteExt;

    let mut file = File::create(dest_path).await?;

    while let Some(chunk) = stream.next().await {
        let chunk = chunk?;
        file.write_all(&chunk).await?;
        downloaded += chunk.len() as u64;

        let progress = (downloaded as f64 / total_size as f64) * 100.0;
        println!("Progresso: {:.1}%", progress);
    }

    Ok(())
}

// ========================================
// ERROR HANDLING
// ========================================

#[derive(Debug)]
enum HttpError {
    Timeout,
    NotFound,
    ServerError,
    NetworkError(String),
}

impl std::fmt::Display for HttpError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            HttpError::Timeout => write!(f, "Timeout della richiesta"),
            HttpError::NotFound => write!(f, "URL non trovato (404)"),
            HttpError::ServerError => write!(f, "Errore server (5xx)"),
            HttpError::NetworkError(msg) => write!(f, "Errore rete: {}", msg),
        }
    }
}

impl std::error::Error for HttpError {}

async fn fetch_url_advanced(url: &str) -> Result<String, HttpError> {
    match reqwest::get(url).await {
        Ok(resp) => {
            match resp.status().as_u16() {
                200..=299 => resp.text().await.map_err(|e| HttpError::NetworkError(e.to_string())),
                404 => Err(HttpError::NotFound),
                500..=599 => Err(HttpError::ServerError),
                _ => Err(HttpError::NetworkError("Errore HTTP non gestito".into())),
            }
        }
        Err(e) if e.is_timeout() => Err(HttpError::Timeout),
        Err(e) => Err(HttpError::NetworkError(e.to_string())),
    }
}
</code></pre>

            </div>
            <div class="box box-exercises">
                <h3>‚úèÔ∏è Esercizi Pratici</h3>
                
<ol>
    <li><strong>Fetch Semplice</strong>
        <p>Implementa GET request a un'API pubblica (es. JSON Placeholder) e mostra risposta in TextView.</p>
    </li>

    <li><strong>Gestione Errori</strong>
        <p>Aggiungi gestione per:</p>
        <ul>
            <li>Timeout (mostra messaggio)</li>
            <li>HTTP error 404, 500 (mostra status)</li>
            <li>Errori di rete (offline)</li>
        </ul>
    </li>

    <li><strong>JSON Parsing</strong>
        <p>Deserializza risposta JSON in struct Rust usando serde. Mostra campi strutturati.</p>
    </li>

    <li><strong>POST Request</strong>
        <p>Aggiungi Form con campi per fare POST request a httpbin.org/post</p>
    </li>

    <li><strong>File Download</strong>
        <p>Implementa download di file con ProgressBar che mostra percentuale completamento.</p>
    </li>

    <li><strong>Challenge: API Explorer</strong>
        <p>Crea app che permette di:</p>
        <ul>
            <li>Fare GET/POST/PUT/DELETE request</li>
            <li>Aggiungere custom headers</li>
            <li>Visualizzare response headers</li>
            <li>Salvare/caricare request history</li>
        </ul>
    </li>
</ol>

            </div>
            <div class="box box-troubleshooting">
                <h3>‚ö†Ô∏è Troubleshooting</h3>
                
<h4>‚ùå UI freeza durante download</h4>
<p><strong>Causa:</strong> Task di download blocca il thread GTK.</p>
<p><strong>Soluzione:</strong> Usa async/await e <code>glib::idle_add_local()</code> per aggiornamenti UI da thread esterno.</p>

<h4>‚ùå Errore "cannot find type in this scope"</h4>
<p><strong>Causa:</strong> Dipendenze tokio non importate.</p>
<p><strong>Soluzione:</strong> Aggiungi <code>use tokio;</code> e configura feature "full" in Cargo.toml</p>

<h4>‚ùå Timeout HTTP</h4>
<p><strong>Soluzione:</strong> Aumenta timeout con:</p>
<pre><code>client.get(url)
    .timeout(Duration::from_secs(30))  // Aumenta a 30s
    .send()
    .await?</code></pre>

<h4>‚ùå JSON non si deserializza</h4>
<p><strong>Soluzione:</strong> Verifica struttura JSON corrisponda a struct Rust usando <code>serde_json::to_value()</code> per debugging.</p>

<h4>üí° Tip: Cancellare Download</h4>
<p>Per permettere cancellazione, usa <code>CancellationToken</code> di tokio:</p>
<pre><code>let token = CancellationToken::new();
// In task async: token.is_cancelled()</code></pre>

<h4>üí° Tip: Connection Pooling</h4>
<p>Riusa client HTTP per migliore performance:</p>
<pre><code>let client = Arc::new(reqwest::Client::new());
// Clona client in ogni task</code></pre>

<h4>üîç Performance Tips</h4>
<ul>
    <li>Usa streaming per file grandi (avoid buffering tutto)</li>
    <li>Abilita compression nella request (gzip)</li>
    <li>Usa connection pooling</li>
    <li>Implementa retry logic per errori transitori</li>
</ul>

<h4>üîç Async/Await Resources</h4>
<ul>
    <li><a href="https://tokio.rs" style="color: #DE8E43;">Tokio Official</a></li>
    <li><a href="https://docs.rs/reqwest" style="color: #DE8E43;">Reqwest Docs</a></li>
    <li>Capitolo Async in Rust Book</li>
</ul>

            </div>
            <nav class="lesson-nav">
                <a href="lesson-4-2.html">‚Üê Lezione Precedente</a>
                <a href="lesson-5-1.html">Lezione Successiva ‚Üí</a>
            </nav>
        </main>
    </div>
    <footer>
        <p>&copy; 2025 Corso Rust Linux Desktop | Creato con ‚ù§Ô∏è per la community Rust</p>
        <p><a href="https://www.rust-lang.org" target="_blank" style="color: #DE8E43;">Rust Programming Language</a> | 
           <a href="https://gtk-rs.org" target="_blank" style="color: #DE8E43;">GTK-rs</a></p>
    </footer>
    <script>document.addEventListener('DOMContentLoaded', function() {
    const currentPage = window.location.pathname.split('/').pop();
    const links = document.querySelectorAll('.sidebar a');
    links.forEach(link => {
        if (link.getAttribute('href') === currentPage) {
            link.classList.add('active');
        }
    });

    const codeBlocks = document.querySelectorAll('.box-code');
    codeBlocks.forEach(block => {
        const button = block.querySelector('.copy-button');
        if (button) {
            button.addEventListener('click', () => {
                const code = block.querySelector('code').textContent;
                navigator.clipboard.writeText(code);
                button.textContent = 'Copiato!';
                setTimeout(() => {
                    button.textContent = 'Copia';
                }, 2000);
            });
        }
    });
});</script>
</body>
</html>