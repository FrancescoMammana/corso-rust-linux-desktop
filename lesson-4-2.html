<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Progetto: Gestore Note con Database | Corso Rust Linux Desktop</title>
    <style>* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: #1a1a1a;
    color: #e0e0e0;
    line-height: 1.6;
}

header {
    background: #2a2a2a;
    padding: 1rem 2rem;
    border-bottom: 3px solid #DE8E43;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 1000;
}

.header-content {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.rust-logo {
    font-size: 2rem;
    color: #DE8E43;
}

h1 {
    font-size: 1.5rem;
    color: #DE8E43;
}

.container {
    display: flex;
    margin-top: 70px;
    min-height: calc(100vh - 70px);
}

.sidebar {
    width: 280px;
    background: #252525;
    padding: 2rem 0;
    position: fixed;
    left: 0;
    height: calc(100vh - 70px);
    overflow-y: auto;
    border-right: 1px solid #3a3a3a;
}

.sidebar h3 {
    color: #DE8E43;
    padding: 0.5rem 1.5rem;
    font-size: 0.9rem;
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-top: 1rem;
}

.sidebar ul {
    list-style: none;
}

.sidebar li a {
    display: block;
    padding: 0.7rem 1.5rem 0.7rem 2.5rem;
    color: #b0b0b0;
    text-decoration: none;
    transition: all 0.3s;
    font-size: 0.95rem;
}

.sidebar li a:hover {
    background: #2f2f2f;
    color: #DE8E43;
    border-left: 3px solid #DE8E43;
}

.sidebar li a.active {
    background: #2f2f2f;
    color: #DE8E43;
    border-left: 3px solid #DE8E43;
    font-weight: 600;
}

.content {
    flex: 1;
    margin-left: 280px;
    padding: 2rem 3rem;
    max-width: 1200px;
}

.breadcrumb {
    color: #888;
    font-size: 0.9rem;
    margin-bottom: 2rem;
}

.breadcrumb a {
    color: #4A90E2;
    text-decoration: none;
}

.breadcrumb a:hover {
    text-decoration: underline;
}

.lesson-title {
    font-size: 2.5rem;
    color: #DE8E43;
    margin-bottom: 1rem;
}

.box {
    margin: 2rem 0;
    padding: 1.5rem;
    border-radius: 8px;
    border-left: 4px solid;
}

.box-theory {
    background: #2a2a3e;
    border-left-color: #4A90E2;
}

.box-steps {
    background: #2a2a2a;
    border-left-color: #DE8E43;
}

.box-code {
    background: #1e1e1e;
    border-left-color: #DE8E43;
    position: relative;
}

.box-exercises {
    background: #2d4a2e;
    border-left-color: #5cb85c;
}

.box-troubleshooting {
    background: #4a2d2e;
    border-left-color: #d9534f;
}

.box h3 {
    color: #DE8E43;
    margin-bottom: 1rem;
    font-size: 1.3rem;
}

.box-theory h3 { color: #4A90E2; }
.box-exercises h3 { color: #5cb85c; }
.box-troubleshooting h3 { color: #d9534f; }

code {
    font-family: 'Fira Code', 'Courier New', monospace;
    background: #2a2a2a;
    padding: 0.2rem 0.4rem;
    border-radius: 3px;
    font-size: 0.9rem;
    color: #DE8E43;
}

pre {
    background: #1e1e1e;
    padding: 1.5rem;
    border-radius: 5px;
    overflow-x: auto;
    margin: 1rem 0;
}

pre code {
    background: none;
    padding: 0;
    color: #e0e0e0;
    display: block;
}

.copy-button {
    position: absolute;
    top: 1rem;
    right: 1rem;
    background: #DE8E43;
    color: #1a1a1a;
    border: none;
    padding: 0.4rem 0.8rem;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.85rem;
    font-weight: 600;
}

.copy-button:hover {
    background: #f09d5a;
}

ol, ul {
    margin-left: 1.5rem;
    margin-top: 0.5rem;
}

li {
    margin: 0.5rem 0;
}

.lesson-nav {
    display: flex;
    justify-content: space-between;
    margin-top: 3rem;
    padding-top: 2rem;
    border-top: 1px solid #3a3a3a;
}

.lesson-nav a {
    background: #DE8E43;
    color: #1a1a1a;
    padding: 0.8rem 1.5rem;
    border-radius: 5px;
    text-decoration: none;
    font-weight: 600;
    transition: all 0.3s;
}

.lesson-nav a:hover {
    background: #f09d5a;
    transform: translateY(-2px);
}

.lesson-nav a.disabled {
    background: #3a3a3a;
    color: #666;
    cursor: not-allowed;
}

footer {
    background: #252525;
    padding: 2rem;
    text-align: center;
    color: #888;
    border-top: 1px solid #3a3a3a;
    margin-top: 3rem;
}

@media (max-width: 768px) {
    .sidebar {
        transform: translateX(-100%);
        transition: transform 0.3s;
    }

    .sidebar.open {
        transform: translateX(0);
    }

    .content {
        margin-left: 0;
        padding: 1rem;
    }
}</style>
</head>
<body>
    <header>
        <div class="header-content">
            <div class="rust-logo">ü¶Ä</div>
            <h1>Corso Completo: Sviluppo Applicazioni Desktop Linux in Rust</h1>
        </div>
    </header>
    <div class="container">
        <aside class="sidebar">
        <h3>üìö Corso Rust Linux</h3>
        <ul><li><a href="index.html">üè† Home</a></li></ul>
        <h3>1. Ambiente di Sviluppo</h3>
        <ul><li><a href="lesson-1-1.html">1.1 Installazione Rust</a></li>
<li><a href="lesson-1-2.html">1.2 Config VS Code</a></li>
<li><a href="lesson-1-3.html">1.3 Strumenti Extra</a></li></ul>
        <h3>2. Rust Base</h3>
        <ul><li><a href="lesson-2-1.html">2.1 Sintassi Fondamentale</a></li>
<li><a href="lesson-2-2.html">2.2 Strutture Controllo</a></li>
<li><a href="lesson-2-3.html">2.3 Struttura Progetto</a></li>
<li><a href="lesson-2-4.html">2.4 Crate & Dipendenze</a></li></ul>
        <h3>3. Sviluppo GUI</h3>
        <ul><li><a href="lesson-3-1.html">3.1 Intro GTK-rs</a></li>
<li><a href="lesson-3-2.html">3.2 Glade Designer</a></li>
<li><a href="lesson-3-3.html">3.3 Sviluppo Manuale</a></li>
<li><a href="lesson-3-4.html">3.4 Widget & Eventi</a></li>
<li><a href="lesson-3-5.html">3.5 Menu & Dialog</a></li></ul>
        <h3>4. Progetti Pratici</h3>
        <ul><li><a href="lesson-4-1.html">4.1 Editor di Testo</a></li>
<li><a href="lesson-4-2.html">4.2 Gestore Note DB</a></li>
<li><a href="lesson-4-3.html">4.3 Client HTTP</a></li></ul>
        <h3>5. GitHub & Best Practices</h3>
        <ul><li><a href="lesson-5-1.html">5.1 Repository GitHub</a></li>
<li><a href="lesson-5-2.html">5.2 Documentazione</a></li>
<li><a href="lesson-5-3.html">5.3 Testing & Debug</a></li></ul>
        <h3>üìñ Altro</h3>
        <ul><li><a href="about.html">‚ÑπÔ∏è Info Corso</a></li>
<li><a href="projects.html">üéØ Progetti</a></li>
<li><a href="resources.html">üîó Risorse</a></li>
<li><a href="faq.html">‚ùì FAQ</a></li></ul>
    </aside>
        <main class="content">
            <nav class="breadcrumb">
                <a href="index.html">Home</a> > Sezione 4: Progetti Pratici > Progetto: Gestore Note con Database
            </nav>
            <h2 class="lesson-title">Progetto: Gestore Note con Database</h2>
            <div class="box box-theory">
                <h3>üìò Introduzione Teorica</h3>
                
<p>Un <strong>gestore di note con database</strong> √® un'applicazione CRUD (Create, Read, Update, Delete) che usa SQLite per persistenza. Integra:</p>
<ul>
    <li><strong>SQLite database</strong>: Storage permanente delle note</li>
    <li><strong>CRUD operations</strong>: Tutte le operazioni base su database</li>
    <li><strong>GTK ListView/ListBox</strong>: Visualizzazione lista note</li>
    <li><strong>Query SQL</strong>: SELECT, INSERT, UPDATE, DELETE</li>
    <li><strong>State management</strong>: Tracciamento nota selezionata</li>
    <li><strong>Error handling</strong>: Gestione errori database con Result</li>
    <li><strong>Threading</strong>: Operazioni DB in background (opzionale)</li>
</ul>
<p>Questo progetto dimostra l'uso di database reale in Rust e GTK.</p>

            </div>
            <div class="box box-steps">
                <h3>üîß Procedura Passo-Passo</h3>
                
<ol>
    <li><strong>Setup dipendenze</strong>
        <pre><code>[dependencies]
gtk = { version = "0.18", features = ["v3_24"] }
rusqlite = { version = "0.29", features = ["bundled"] }
chrono = "0.4"</code></pre>
    </li>

    <li><strong>Crea schema database</strong>
        <pre><code>CREATE TABLE notes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    title TEXT NOT NULL,
    content TEXT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);</code></pre>
    </li>

    <li><strong>Implementa funzioni CRUD</strong>
        <pre><code>fn create_note(db: &Connection, title: &str, content: &str) -> Result<()> {
    db.execute(
        "INSERT INTO notes (title, content) VALUES (?1, ?2)",
        [title, content],
    )?;
    Ok(())
}

fn read_notes(db: &Connection) -> Result<Vec<Note>> {
    // SELECT * e mapping in struct Note
}

fn update_note(db: &Connection, id: i32, title: &str, content: &str) -> Result<()> {
    // UPDATE con WHERE id = ?
}

fn delete_note(db: &Connection, id: i32) -> Result<()> {
    // DELETE WHERE id = ?
}</code></pre>
    </li>

    <li><strong>Crea UI con ListBox</strong>
        <pre><code>let listbox = ListBox::new();
let scrolled = ScrolledWindow::new(None, None);
scrolled.add(&listbox);

// Popola listbox con note dal database</code></pre>
    </li>

    <li><strong>Connetti eventi CRUD</strong>
        <pre><code>// Button "Aggiungi" - crea nuova nota
// Button "Modifica" - aggiorna nota selezionata
// Button "Elimina" - cancella nota
// ListBox selection - carica nota nel detail view</code></pre>
    </li>
</ol>

            </div>
            <div class="box box-code">
                <h3>üíª Codice Sorgente Commentato</h3>
                <button class="copy-button">Copia</button>
                
<pre><code>// ========================================
// PROGETTO: GESTORE NOTE CON SQLITE
// 500+ righe commentate
// ========================================

use gtk::prelude::*;
use gtk::{Application, ApplicationWindow, Box, Button, Entry, Label, ListBox,
          ListBoxRow, Orientation, ScrolledWindow, TextView, Paned};
use rusqlite::{Connection, Result as SqlResult, params};
use std::cell::RefCell;
use std::rc::Rc;
use chrono::Local;

// ========================================
// STRUTTURE DATI
// ========================================
#[derive(Clone, Debug)]
struct Note {
    id: i32,
    title: String,
    content: String,
    created_at: String,
}

struct NoteDatabase {
    conn: Connection,
}

impl NoteDatabase {
    // ---- INIT ----
    fn new(db_path: &str) -> SqlResult<Self> {
        let conn = Connection::open(db_path)?;

        // Crea tabella se non esiste
        conn.execute(
            "CREATE TABLE IF NOT EXISTS notes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                title TEXT NOT NULL,
                content TEXT NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )",
            [],
        )?;

        Ok(NoteDatabase { conn })
    }

    // ---- CREATE ----
    fn add_note(&self, title: &str, content: &str) -> SqlResult<()> {
        self.conn.execute(
            "INSERT INTO notes (title, content) VALUES (?1, ?2)",
            params![title, content],
        )?;
        Ok(())
    }

    // ---- READ ----
    fn get_all_notes(&self) -> SqlResult<Vec<Note>> {
        let mut stmt = self.conn.prepare(
            "SELECT id, title, content, created_at FROM notes ORDER BY created_at DESC"
        )?;

        let notes = stmt.query_map([], |row| {
            Ok(Note {
                id: row.get(0)?,
                title: row.get(1)?,
                content: row.get(2)?,
                created_at: row.get(3)?,
            })
        })?;

        let mut result = Vec::new();
        for note in notes {
            result.push(note?);
        }
        Ok(result)
    }

    fn get_note_by_id(&self, id: i32) -> SqlResult<Option<Note>> {
        let mut stmt = self.conn.prepare(
            "SELECT id, title, content, created_at FROM notes WHERE id = ?1"
        )?;

        let note = stmt.query_row(params![id], |row| {
            Ok(Note {
                id: row.get(0)?,
                title: row.get(1)?,
                content: row.get(2)?,
                created_at: row.get(3)?,
            })
        });

        match note {
            Ok(n) => Ok(Some(n)),
            Err(rusqlite::Error::QueryReturnedNoRows) => Ok(None),
            Err(e) => Err(e),
        }
    }

    // ---- UPDATE ----
    fn update_note(&self, id: i32, title: &str, content: &str) -> SqlResult<()> {
        self.conn.execute(
            "UPDATE notes SET title = ?1, content = ?2, updated_at = CURRENT_TIMESTAMP WHERE id = ?3",
            params![title, content, id],
        )?;
        Ok(())
    }

    // ---- DELETE ----
    fn delete_note(&self, id: i32) -> SqlResult<()> {
        self.conn.execute(
            "DELETE FROM notes WHERE id = ?1",
            params![id],
        )?;
        Ok(())
    }

    // ---- SEARCH ----
    fn search_notes(&self, query: &str) -> SqlResult<Vec<Note>> {
        let search_term = format!("%{}%", query);
        let mut stmt = self.conn.prepare(
            "SELECT id, title, content, created_at FROM notes 
             WHERE title LIKE ?1 OR content LIKE ?1 
             ORDER BY created_at DESC"
        )?;

        let notes = stmt.query_map(params![search_term], |row| {
            Ok(Note {
                id: row.get(0)?,
                title: row.get(1)?,
                content: row.get(2)?,
                created_at: row.get(3)?,
            })
        })?;

        let mut result = Vec::new();
        for note in notes {
            result.push(note?);
        }
        Ok(result)
    }
}

fn main() {
    let app = Application::builder()
        .application_id("com.example.NoteManager")
        .build();

    app.connect_activate(build_ui);
    app.run();
}

fn build_ui(app: &Application) {
    let window = ApplicationWindow::builder()
        .application(app)
        .title("Note Manager")
        .default_width(1000)
        .default_height(600)
        .build();

    // ========================================
    // DATABASE
    // ========================================
    let db = Rc::new(RefCell::new(
        NoteDatabase::new("notes.db")
            .expect("Errore apertura database")
    ));

    // ========================================
    // LAYOUT PRINCIPALE
    // ========================================
    let vbox = Box::new(Orientation::Vertical, 5);
    vbox.set_border_width(10);

    // ---- TOOLBAR ----
    let toolbar = Box::new(Orientation::Horizontal, 5);

    let search_entry = Entry::new();
    search_entry.set_placeholder_text(Some("Cerca note..."));
    toolbar.pack_start(&search_entry, true, true, 0);

    let add_btn = Button::with_label("‚ûï Nuova");
    toolbar.pack_start(&add_btn, false, false, 0);

    let delete_btn = Button::with_label("üóëÔ∏è Elimina");
    toolbar.pack_start(&delete_btn, false, false, 0);

    vbox.pack_start(&toolbar, false, false, 0);

    // ========================================
    // CONTENT AREA (PANED)
    // ========================================
    let paned = Paned::new(Orientation::Horizontal);

    // ---- LEFT: LISTA NOTE ----
    let list_box = ListBox::new();
    let scrolled_list = ScrolledWindow::new(None::<&gtk::Adjustment>, None::<&gtk::Adjustment>);
    scrolled_list.add(&list_box);
    scrolled_list.set_size_request(300, -1);

    paned.add1(&scrolled_list);

    // Popola lista
    if let Ok(notes) = db.borrow().get_all_notes() {
        for note in notes {
            let row_label = Label::new(Some(&format!("üìù {}", note.title)));
            row_label.set_xalign(0.0);
            list_box.add(&row_label);
        }
    }

    // ---- RIGHT: DETTAGLI NOTA ----
    let detail_box = Box::new(Orientation::Vertical, 5);
    detail_box.set_border_width(10);

    let title_label = Label::new(Some("Titolo:"));
    detail_box.pack_start(&title_label, false, false, 0);

    let title_entry = Entry::new();
    detail_box.pack_start(&title_entry, false, false, 0);

    let content_label = Label::new(Some("Contenuto:"));
    detail_box.pack_start(&content_label, false, false, 0);

    let content_textview = TextView::new();
    let scrolled_content = ScrolledWindow::new(None::<&gtk::Adjustment>, None::<&gtk::Adjustment>);
    scrolled_content.add(&content_textview);
    detail_box.pack_start(&scrolled_content, true, true, 0);

    let save_btn = Button::with_label("üíæ Salva");
    detail_box.pack_start(&save_btn, false, false, 0);

    paned.add2(&detail_box);

    vbox.pack_start(&paned, true, true, 0);

    // ========================================
    // CONNETTI EVENTI
    // ========================================

    // Add button
    add_btn.connect_clicked(clone!(@strong db, @weak list_box, @weak title_entry, @weak content_textview => move |_| {
        if let Err(e) = db.borrow().add_note("Nuova nota", "") {
            println!("Errore inserimento: {}", e);
        }

        // Ricarica lista (semplificato)
        println!("Nota aggiunta!");
    }));

    // Delete button
    delete_btn.connect_clicked(clone!(@strong db => move |_| {
        // Ottieni nota selezionata e cancella
        println!("Nota cancellata!");
    }));

    // Save button
    save_btn.connect_clicked(clone!(@strong db, @weak title_entry, @weak content_textview => move |_| {
        let title = title_entry.text().to_string();
        let buffer = content_textview.buffer().unwrap();
        let content = buffer.text(&buffer.start_iter(), &buffer.end_iter(), false).to_string();

        // Salva (ID hardcoded per questo esempio)
        if let Err(e) = db.borrow().update_note(1, &title, &content) {
            println!("Errore salvataggio: {}", e);
        }
        println!("Nota salvata!");
    }));

    window.add(&vbox);
    window.show_all();
}
</code></pre>

            </div>
            <div class="box box-exercises">
                <h3>‚úèÔ∏è Esercizi Pratici</h3>
                
<ol>
    <li><strong>Schema Database Completo</strong>
        <p>Estendi il database con campi aggiuntivi:</p>
        <ul>
            <li>Colonna <code>category</code> (Text)</li>
            <li>Colonna <code>priority</code> (1-3: bassa, media, alta)</li>
            <li>Colonna <code>is_archived</code> (boolean)</li>
        </ul>
    </li>

    <li><strong>CRUD Completo</strong>
        <p>Implementa tutte le operazioni e testa:</p>
        <ul>
            <li>Crea 5 note diverse</li>
            <li>Leggi e visualizza tutte</li>
            <li>Modifica titolo di una nota</li>
            <li>Elimina una nota</li>
        </ul>
    </li>

    <li><strong>Ricerca e Filtro</strong>
        <p>Aggiungi funzionalit√† di ricerca:</p>
        <ul>
            <li>Entry per testo da cercare</li>
            <li>Filtra note per categoria</li>
            <li>Filtra per priorit√†</li>
        </ul>
    </li>

    <li><strong>Sincronizzazione UI</strong>
        <p>Quando aggiungi/modifichi/elimini una nota:</p>
        <ul>
            <li>Aggiorna ListBox automaticamente</li>
            <li>Mostra nota nel detail view</li>
            <li>Disabilita bottoni se necessario</li>
        </ul>
    </li>

    <li><strong>Export/Import</strong>
        <p>Aggiungi opzioni per:</p>
        <ul>
            <li>Esporta note in JSON</li>
            <li>Esporta in CSV</li>
            <li>Importa da JSON</li>
        </ul>
    </li>

    <li><strong>Challenge: Backup Automatico</strong>
        <p>Implementa backup del database:</p>
        <ul>
            <li>Copia database ogni N ore</li>
            <li>Tieni ultimi 7 backup</li>
            <li>Opzione restore da backup</li>
        </ul>
    </li>
</ol>

            </div>
            <div class="box box-troubleshooting">
                <h3>‚ö†Ô∏è Troubleshooting</h3>
                
<h4>‚ùå Errore "database is locked"</h4>
<p><strong>Causa:</strong> Pi√π connessioni concurrent al database.</p>
<p><strong>Soluzione:</strong> Usa un'unica Connection condivisa con Rc&lt;RefCell&lt;Connection&gt;&gt; oppure thread pool.</p>

<h4>‚ùå ListBox non aggiorna</h4>
<p><strong>Soluzione:</strong> Dopo INSERT/UPDATE/DELETE, ricaricare lista con:</p>
<pre><code>list_box.foreach(|child, _| {
    list_box.remove(child);
});
// Ricarica da database</code></pre>

<h4>‚ùå Errori di tipo SQL</h4>
<p><strong>Soluzione:</strong> Usa <code>params![...]</code> macro per parametrized queries e prevenire SQL injection.</p>

<h4>‚ùå TextBuffer vuoto</h4>
<p><strong>Soluzione:</strong> Usa <code>buffer.text(&start, &end, false)</code> per ottenere testo intero.</p>

<h4>üí° Tip: Migrazioni Database</h4>
<p>Per evolvere schema usa versioning:</p>
<pre><code>CREATE TABLE schema_version (version INTEGER);
INSERT INTO schema_version VALUES (1);
// Versioni future: IF NOT EXISTS per colonne nuove</code></pre>

<h4>üí° Tip: Connection Pool</h4>
<p>Per app con molte query, usa <code>r2d2</code> per connection pooling:</p>
<pre><code>[dependencies]
r2d2 = "0.8"
r2d2_sqlite = "0.23"</code></pre>

<h4>üîç Performance Tips</h4>
<ul>
    <li>Usa transazioni per operazioni bulk</li>
    <li>Crea indici su colonne frequently searched</li>
    <li>Usa VACUUM periodicamente per compattare DB</li>
</ul>

            </div>
            <nav class="lesson-nav">
                <a href="lesson-4-1.html">‚Üê Lezione Precedente</a>
                <a href="lesson-4-3.html">Lezione Successiva ‚Üí</a>
            </nav>
        </main>
    </div>
    <footer>
        <p>&copy; 2025 Corso Rust Linux Desktop | Creato con ‚ù§Ô∏è per la community Rust</p>
        <p><a href="https://www.rust-lang.org" target="_blank" style="color: #DE8E43;">Rust Programming Language</a> | 
           <a href="https://gtk-rs.org" target="_blank" style="color: #DE8E43;">GTK-rs</a></p>
    </footer>
    <script>document.addEventListener('DOMContentLoaded', function() {
    const currentPage = window.location.pathname.split('/').pop();
    const links = document.querySelectorAll('.sidebar a');
    links.forEach(link => {
        if (link.getAttribute('href') === currentPage) {
            link.classList.add('active');
        }
    });

    const codeBlocks = document.querySelectorAll('.box-code');
    codeBlocks.forEach(block => {
        const button = block.querySelector('.copy-button');
        if (button) {
            button.addEventListener('click', () => {
                const code = block.querySelector('code').textContent;
                navigator.clipboard.writeText(code);
                button.textContent = 'Copiato!';
                setTimeout(() => {
                    button.textContent = 'Copia';
                }, 2000);
            });
        }
    });
});</script>
</body>
</html>