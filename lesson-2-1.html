<!DOCTYPE html>
<html lang="it"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sintassi e Concetti Fondamentali | Corso Rust Linux Desktop</title><link rel="icon" type="image/png" href="favicon.png"><style>* {margin: 0; padding: 0; box-sizing: border-box;}
body {font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: #1a1a1a; color: #e0e0e0; line-height: 1.6;}
header {background: #2a2a2a; padding: 1rem 2rem; border-bottom: 3px solid #DE8E43; position: fixed; top: 0; left: 0; right: 0; z-index: 1000; display: flex; align-items: center; justify-content: space-between;}
.header-content {display: flex; align-items: center; gap: 1rem;} .rust-logo {font-size: 2rem; color: #DE8E43;} h1 {font-size: 1.5rem; color: #DE8E43;}
.menu-toggle {display: none; background: none; border: none; color: #DE8E43; font-size: 2rem; cursor: pointer; padding: 0.5rem;}
.container {display: flex; margin-top: 70px; min-height: calc(100vh - 70px);}
.sidebar {width: 280px; background: #252525; padding: 2rem 0; position: fixed; left: 0; height: calc(100vh - 70px); overflow-y: auto; border-right: 1px solid #3a3a3a; z-index: 999;}
.sidebar h3 {color: #DE8E43; padding: 0.5rem 1.5rem; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 1px; margin-top: 1rem;}
.sidebar ul {list-style: none;} .sidebar li a {display: block; padding: 0.7rem 1.5rem 0.7rem 2.5rem; color: #b0b0b0; text-decoration: none; transition: all 0.3s; font-size: 0.95rem;}
.sidebar li a:hover {background: #2f2f2f; color: #DE8E43; border-left: 3px solid #DE8E43;}
.sidebar li a.active {background: #2f2f2f; color: #DE8E43; border-left: 3px solid #DE8E43; font-weight: 600;}
.content {flex: 1; margin-left: 280px; padding: 2rem 3rem; max-width: 1200px;}
.breadcrumb {color: #888; font-size: 0.9rem; margin-bottom: 2rem;} .breadcrumb a {color: #4A90E2; text-decoration: none;} .breadcrumb a:hover {text-decoration: underline;}
.lesson-title {font-size: 2.5rem; color: #DE8E43; margin-bottom: 1rem;}
.box {margin: 2rem 0; padding: 1.5rem; border-radius: 8px; border-left: 4px solid;}
.box-theory {background: #2a2a3e; border-left-color: #4A90E2;} .box-steps {background: #2a2a2a; border-left-color: #DE8E43;} .box-code {background: #1e1e1e; border-left-color: #DE8E43; position: relative;} .box-exercises {background: #2d4a2e; border-left-color: #5cb85c;} .box-troubleshooting {background: #4a2d2e; border-left-color: #d9534f;}
.box h3 {color: #DE8E43; margin-bottom: 1rem; font-size: 1.3rem;} .box-theory h3 {color: #4A90E2;} .box-exercises h3 {color: #5cb85c;} .box-troubleshooting h3 {color: #d9534f;}
code {font-family: 'Fira Code', 'Courier New', monospace; background: #2a2a2a; padding: 0.2rem 0.4rem; border-radius: 3px; font-size: 0.9rem; color: #DE8E43;}
pre {background: #1e1e1e; padding: 1.5rem; border-radius: 5px; overflow-x: auto; margin: 1rem 0;} pre code {background: none; padding: 0; color: #e0e0e0; display: block;}
.copy-button {position: absolute; top: 1rem; right: 1rem; background: #DE8E43; color: #1a1a1a; border: none; padding: 0.4rem 0.8rem; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 600;} .copy-button:hover {background: #f09d5a;}
ol, ul {margin-left: 1.5rem; margin-top: 0.5rem;} li {margin: 0.5rem 0;}
.lesson-nav {display: flex; justify-content: space-between; margin-top: 3rem; padding-top: 2rem; border-top: 1px solid #3a3a3a; gap: 1rem;}
.lesson-nav a {background: #DE8E43; color: #1a1a1a; padding: 0.8rem 1.5rem; border-radius: 5px; text-decoration: none; font-weight: 600; transition: all 0.3s; text-align: center;}
.lesson-nav a:hover {background: #f09d5a; transform: translateY(-2px);} .lesson-nav a.disabled {background: #3a3a3a; color: #666; cursor: not-allowed;}
footer {background: #252525; padding: 2rem; text-align: center; color: #888; border-top: 1px solid #3a3a3a; margin-top: 3rem;}
@media (max-width: 900px) {.menu-toggle {display: block;} .sidebar {position: fixed; left: -280px; top: 70px; height: calc(100vh - 70px); transition: left 0.3s ease; box-shadow: 2px 0 10px rgba(0,0,0,0.5);} .sidebar.open {left: 0;} .content {margin-left: 0; padding: 1.5rem; width: 100%;} .lesson-title {font-size: 2rem;} .box {margin: 1.5rem 0; padding: 1.2rem;} .lesson-nav {flex-direction: column;} .lesson-nav a {width: 100%;}}
@media (max-width: 600px) {header {padding: 0.8rem 1rem;} h1 {font-size: 1.1rem;} .rust-logo {font-size: 1.5rem;} .sidebar {width: 85vw; left: -85vw;} .content {padding: 1rem;} .lesson-title {font-size: 1.6rem;} .box {margin: 1rem 0; padding: 1rem;} .box h3 {font-size: 1.1rem;} pre {padding: 1rem; font-size: 0.85rem;}}
@media (max-width: 400px) {h1 {font-size: 0.95rem;} .sidebar {width: 100vw; left: -100vw;} .lesson-title {font-size: 1.4rem;}}</style></head>
<body><header><div class="header-content"><div class="rust-logo">ü¶Ä</div><h1>Corso Completo: Sviluppo Applicazioni Desktop Linux in Rust</h1></div><button class="menu-toggle" aria-label="Menu">‚ò∞</button></header><div class="container"><aside class="sidebar"><h3>üìö Corso Rust Linux</h3><ul><li><a href="index.html">üè† Home</a></li></ul>
<h3>1. Ambiente di Sviluppo</h3><ul><li><a href="lesson-1-1.html">1.1 Installazione Rust</a></li><li><a href="lesson-1-2.html">1.2 Config VS Code</a></li><li><a href="lesson-1-3.html">1.3 Strumenti Extra</a></li></ul>
<h3>2. Rust Base</h3><ul><li><a href="lesson-2-1.html">2.1 Sintassi Fondamentale</a></li><li><a href="lesson-2-2.html">2.2 Strutture Controllo</a></li><li><a href="lesson-2-3.html">2.3 Struttura Progetto</a></li><li><a href="lesson-2-4.html">2.4 Crate & Dipendenze</a></li></ul>
<h3>3. Sviluppo GUI</h3><ul><li><a href="lesson-3-1.html">3.1 Intro GTK-rs</a></li><li><a href="lesson-3-2.html">3.2 Glade Designer</a></li><li><a href="lesson-3-3.html">3.3 Sviluppo Manuale</a></li><li><a href="lesson-3-4.html">3.4 Widget & Eventi</a></li><li><a href="lesson-3-5.html">3.5 Menu & Dialog</a></li></ul>
<h3>4. Progetti Pratici</h3><ul><li><a href="lesson-4-1.html">4.1 Editor di Testo</a></li><li><a href="lesson-4-2.html">4.2 Gestore Note DB</a></li><li><a href="lesson-4-3.html">4.3 Client HTTP</a></li></ul>
<h3>5. GitHub & Best Practices</h3><ul><li><a href="lesson-5-1.html">5.1 Repository GitHub</a></li><li><a href="lesson-5-2.html">5.2 Documentazione</a></li><li><a href="lesson-5-3.html">5.3 Testing & Debug</a></li></ul>
<h3>üìñ Altro</h3><ul><li><a href="about.html">‚ÑπÔ∏è Info Corso</a></li><li><a href="projects.html">üéØ Progetti</a></li><li><a href="resources.html">üîó Risorse</a></li><li><a href="faq.html">‚ùì FAQ</a></li></ul></aside><main class="content">
<nav class="breadcrumb"><a href="index.html">Home</a> > Sezione 2: Rust Base > Sintassi e Concetti Fondamentali</nav><h2 class="lesson-title">Sintassi e Concetti Fondamentali</h2>
<div class="box box-theory"><h3>üìò Introduzione Teorica</h3>
<p><strong>Rust</strong> introduce concetti unici per garantire sicurezza memoria senza garbage collector:</p>
<ul>
    <li><strong>Ownership</strong>: Ogni valore ha un unico proprietario</li>
    <li><strong>Borrowing</strong>: Prestito temporaneo (immutable &T o mutable &mut T)</li>
    <li><strong>Lifetimes</strong>: Durata dei riferimenti verificata a compile-time</li>
    <li><strong>Move semantics</strong>: Trasferimento propriet√† tra variabili</li>
    <li><strong>Type inference</strong>: Tipi dedotti automaticamente</li>
</ul>
<p>Questi concetti prevengono data races, null pointer e memory leaks a compile-time.</p>
</div>
<div class="box box-steps"><h3>üîß Procedura Passo-Passo</h3>
<ol>
    <li><strong>Ownership base</strong>
        <pre><code>let s1 = String::from("hello");
let s2 = s1;  // s1 non pi√π valido (moved)
// println!("{}", s1);  // ERRORE!</code></pre>
    </li>

    <li><strong>Borrowing immutabile</strong>
        <pre><code>let s = String::from("hello");
let len = calcola_len(&s);  // Prestito
println!("{} len={}", s, len);  // s ancora valido</code></pre>
    </li>

    <li><strong>Borrowing mutabile</strong>
        <pre><code>let mut s = String::from("hello");
modifica(&mut s);
println!("{}", s);</code></pre>
    </li>

    <li><strong>Regole borrowing</strong>
        <ul>
            <li>Infiniti prestiti immutabili (&T) OPPURE</li>
            <li>Un solo prestito mutabile (&mut T)</li>
            <li>Mai &T e &mut T contemporaneamente</li>
        </ul>
    </li>

    <li><strong>Lifetimes espliciti</strong>
        <pre><code>fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}</code></pre>
    </li>
</ol>
</div>
<div class="box box-code"><h3>üíª Codice Sorgente Commentato</h3><button class="copy-button">Copia</button>
<pre><code>// ========================================
// OWNERSHIP E BORROWING
// ========================================

fn main() {
    // ---- OWNERSHIP ESEMPIO 1 ----
    let s1 = String::from("hello");
    let s2 = s1;  // s1 moved to s2

    // println!("{}", s1);  // ERRORE: s1 non pi√π valido
    println!("{}", s2);  // OK

    // ---- OWNERSHIP ESEMPIO 2: CLONE ----
    let s3 = String::from("world");
    let s4 = s3.clone();  // Deep copy
    println!("{} {}", s3, s4);  // Entrambi validi

    // ---- BORROWING IMMUTABILE ----
    let s = String::from("hello");
    let len = calcola_len(&s);  // Prestito &s
    println!("'{}' ha lunghezza {}", s, len);

    // ---- BORROWING MUTABILE ----
    let mut s = String::from("hello");
    aggiungi_mondo(&mut s);
    println!("{}", s);  // "hello, world!"

    // ---- SCOPE E LIFETIME ----
    let r;
    {
        let x = 5;
        // r = &x;  // ERRORE: x vive solo in questo scope
    }
    // println!("{}", r);  // ERRORE
}

fn calcola_len(s: &String) -> usize {
    s.len()  // Legge ma non possiede s
}

fn aggiungi_mondo(s: &mut String) {
    s.push_str(", world!");
}

// ========================================
// LIFETIMES
// ========================================

// Lifetime esplicito: 'a dice che il return vive quanto i parametri
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

// Struct con lifetime
struct Estratto<'a> {
    parte: &'a str,
}

impl<'a> Estratto<'a> {
    fn annuncia(&self) {
        println!("Estratto: {}", self.parte);
    }
}

// ========================================
// TIPI BASE E TYPE INFERENCE
// ========================================

fn tipi_base() {
    // Interi
    let x: i32 = 42;
    let y = 10u8;  // u8 specificato

    // Float
    let f: f64 = 3.14;

    // Boolean
    let t = true;
    let f: bool = false;

    // Char (Unicode)
    let c = 'z';
    let emoji = 'üòé';

    // Tuple
    let tup: (i32, f64, u8) = (500, 6.4, 1);
    let (x, y, z) = tup;  // Destructuring
    println!("{} {} {}", x, y, z);

    // Array (fixed size)
    let arr = [1, 2, 3, 4, 5];
    let primo = arr[0];

    // Slice
    let slice = &arr[1..3];  // [2, 3]
}

// ========================================
// STRUCT E ENUM
// ========================================

#[derive(Debug)]
struct Persona {
    nome: String,
    eta: u32,
}

impl Persona {
    fn new(nome: String, eta: u32) -> Self {
        Persona { nome, eta }
    }

    fn saluta(&self) {
        println!("Ciao, sono {} e ho {} anni", self.nome, self.eta);
    }
}

#[derive(Debug)]
enum Risultato<T, E> {
    Ok(T),
    Err(E),
}

// ========================================
// OPTION E RESULT
// ========================================

fn divide(a: i32, b: i32) -> Option<i32> {
    if b == 0 {
        None
    } else {
        Some(a / b)
    }
}

fn parse_numero(s: &str) -> Result<i32, String> {
    match s.parse::<i32>() {
        Ok(n) => Ok(n),
        Err(_) => Err(format!("'{}' non √® un numero valido", s)),
    }
}

// ========================================
// PATTERN MATCHING
// ========================================

fn analizza_numero(n: i32) {
    match n {
        0 => println!("zero"),
        1 | 2 => println!("uno o due"),
        3..=9 => println!("da 3 a 9"),
        n if n < 0 => println!("negativo: {}", n),
        _ => println!("altro: {}", n),
    }
}

// ========================================
// CLOSURES
// ========================================

fn closures_esempio() {
    let x = 4;

    // Closure che cattura x
    let uguale_a_x = |z| z == x;

    let y = 4;
    assert!(uguale_a_x(y));

    // Closure con move
    let s = String::from("hello");
    let stampa = move || println!("{}", s);
    stampa();
    // println!("{}", s);  // ERRORE: s moved
}
</code></pre>
</div>
<div class="box box-exercises"><h3>‚úèÔ∏è Esercizi Pratici</h3>
<ol>
    <li><strong>Ownership Base</strong>
        <p>Crea 3 variabili String, fai move di una, clone di un'altra, lascia la terza intatta. Stampa quelle valide.</p>
    </li>

    <li><strong>Borrowing Funzioni</strong>
        <p>Scrivi funzioni che:</p>
        <ul>
            <li>Ricevono &String e ritornano lunghezza</li>
            <li>Ricevono &mut String e aggiungono testo</li>
            <li>Ricevono ownership e ritornano String modificato</li>
        </ul>
    </li>

    <li><strong>Lifetimes</strong>
        <p>Crea funzione che prende due &str e ritorna il pi√π lungo. Aggiungi lifetime esplicito.</p>
    </li>

    <li><strong>Struct con Methods</strong>
        <p>Crea struct Rettangolo con larghezza/altezza. Implementa metodi area() e perimetro().</p>
    </li>

    <li><strong>Option e Result</strong>
        <p>Scrivi funzione che cerca elemento in Vec. Usa Option per return. Gestisci con match.</p>
    </li>

    <li><strong>Challenge: Parser</strong>
        <p>Crea parser che legge stringa tipo "3+5" e ritorna Result<i32, String> con risultato o errore.</p>
    </li>
</ol>
</div>
<div class="box box-troubleshooting"><h3>‚ö†Ô∏è Troubleshooting</h3>
<h4>‚ùå Errore "value borrowed after move"</h4>
<p><strong>Causa:</strong> Usi variabile dopo averla mossa.</p>
<p><strong>Soluzione:</strong> Usa .clone() o borrowing (&).</p>

<h4>‚ùå Errore "cannot borrow as mutable"</h4>
<p><strong>Causa:</strong> Variabile non dichiarata mut.</p>
<p><strong>Soluzione:</strong> <code>let mut x = ...</code></p>

<h4>‚ùå Errore "multiple mutable borrows"</h4>
<p><strong>Causa:</strong> Due &mut contemporanei.</p>
<p><strong>Soluzione:</strong> Usa uno alla volta in scope diversi.</p>

<h4>üí° Tip: Borrow Checker</h4>
<p>Il borrow checker previene bugs a compile-time. Fidati degli errori!</p>

<h4>üí° Tip: Debug Ownership</h4>
<p>Usa <code>dbg!(&variabile)</code> per vedere senza muovere.</p>
</div>
<nav class="lesson-nav"><a href="lesson-1-3.html">‚Üê Precedente</a><a href="lesson-2-2.html">Successiva ‚Üí</a></nav></main></div><footer><p>&copy; 2025 Corso Rust Linux Desktop | Creato con ‚ù§Ô∏è per la community Rust</p>
<p><a href="https://www.rust-lang.org" target="_blank" style="color: #DE8E43;">Rust Programming Language</a> | <a href="https://gtk-rs.org" target="_blank" style="color: #DE8E43;">GTK-rs</a></p></footer><script>document.addEventListener('DOMContentLoaded', function() {
const currentPage = window.location.pathname.split('/').pop(); const links = document.querySelectorAll('.sidebar a');
links.forEach(link => {if (link.getAttribute('href') === currentPage) {link.classList.add('active');}});
const codeBlocks = document.querySelectorAll('.box-code'); codeBlocks.forEach(block => {const button = block.querySelector('.copy-button');
if (button) {button.addEventListener('click', () => {const code = block.querySelector('code').textContent; navigator.clipboard.writeText(code);
button.textContent = 'Copiato!'; setTimeout(() => {button.textContent = 'Copia';}, 2000);});}});
const menuToggle = document.querySelector('.menu-toggle'); const sidebar = document.querySelector('.sidebar');
if (menuToggle && sidebar) {menuToggle.addEventListener('click', () => {sidebar.classList.toggle('open');});
const sidebarLinks = sidebar.querySelectorAll('a'); sidebarLinks.forEach(link => {link.addEventListener('click', () => {if (window.innerWidth <= 900) {sidebar.classList.remove('open');}});});
document.addEventListener('click', (e) => {if (window.innerWidth <= 900) {if (!sidebar.contains(e.target) && !menuToggle.contains(e.target)) {sidebar.classList.remove('open');}}});}});</script></body></html>