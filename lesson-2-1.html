<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sintassi e Concetti Fondamentali | Corso Rust Linux Desktop</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <div class="header-content">
            <div class="rust-logo">ü¶Ä</div>
            <h1>Corso Completo: Sviluppo Applicazioni Desktop Linux in Rust</h1>
        </div>
        <button class="menu-toggle" aria-label="Menu">‚ò∞</button>
    </header>

    <div class="container">
        <aside class="sidebar">
            <h3>üìö Corso</h3>
            <ul><li><a href="index.html">üè† Home</a></li></ul>
            <h3>1. Ambiente</h3>
            <ul><li><a href="lesson-1-1.html">1.1 Installazione Rust</a></li>
            <li><a href="lesson-1-2.html">1.2 Config VS Code</a></li>
            <li><a href="lesson-1-3.html">1.3 Strumenti Extra</a></li></ul>
            <h3>2. Rust Base</h3>
            <ul><li><a href="lesson-2-1.html">2.1 Sintassi</a></li>
            <li><a href="lesson-2-2.html">2.2 Controllo</a></li>
            <li><a href="lesson-2-3.html">2.3 Progetto</a></li>
            <li><a href="lesson-2-4.html">2.4 Crate</a></li></ul>
            <h3>3. GUI</h3>
            <ul><li><a href="lesson-3-1.html">3.1 GTK-rs</a></li>
            <li><a href="lesson-3-2.html">3.2 Glade</a></li>
            <li><a href="lesson-3-3.html">3.3 Manuale</a></li>
            <li><a href="lesson-3-4.html">3.4 Widget</a></li>
            <li><a href="lesson-3-5.html">3.5 Menu</a></li></ul>
            <h3>4. Progetti</h3>
            <ul><li><a href="lesson-4-1.html">4.1 Editor</a></li>
            <li><a href="lesson-4-2.html">4.2 Note DB</a></li>
            <li><a href="lesson-4-3.html">4.3 HTTP</a></li></ul>
            <h3>5. GitHub</h3>
            <ul><li><a href="lesson-5-1.html">5.1 Repository</a></li>
            <li><a href="lesson-5-2.html">5.2 Documentazione</a></li>
            <li><a href="lesson-5-3.html">5.3 Testing</a></li></ul>
            <h3>üìñ Risorse</h3>
            <ul><li><a href="about.html">‚ÑπÔ∏è Info Corso</a></li>
            <li><a href="resources.html">üîó Risorse</a></li>
            <li><a href="faq.html">‚ùì FAQ</a></li></ul>
        </aside>

        <main class="content">
            <nav class="breadcrumb"><a href="index.html">Home</a> > Sezione 2: Rust Base > Sintassi e Concetti Fondamentali</nav>
            <h2 class="lesson-title">Sintassi e Concetti Fondamentali</h2>

            <div class="box box-theory">
                <h3>üìò Introduzione Teorica</h3>
                <p><strong>Fondamenti Rust:</strong> Ownership, borrowing, lifetimes.</p>
<ul>
    <li><strong>Ownership</strong>: Ogni valore ha un proprietario unico</li>
    <li><strong>Borrowing</strong>: Riferimenti temporanei (&)</li>
    <li><strong>Move semantics</strong>: Trasferimento propriet√†</li>
    <li><strong>Lifetimes</strong>: Validit√† riferimenti</li>
    <li><strong>Pattern matching</strong>: Destrutturazione valori</li>
</ul>
            </div>

            <div class="box box-steps">
                <h3>üîß Procedura Passo-Passo</h3>
                <ol>
    <li><strong>Variabili e binding</strong>
        <pre><code>let x = 5;
let mut y = 10;
let z: i32 = 15;</code></pre>
    </li>

    <li><strong>Ownership e move</strong>
        <pre><code>let s1 = String::from("ciao");
let s2 = s1;
println!("{}", s2);</code></pre>
    </li>

    <li><strong>Borrowing</strong>
        <pre><code>let s1 = String::from("ciao");
let len = calcola_lunghezza(&s1);
println!("{}", s1);</code></pre>
    </li>
</ol>
            </div>

            <div class="box box-code">
                <h3>üíª Codice Sorgente Commentato</h3>
                <h4>1. Ownership - Il Concetto Fondamentale</h4>
<p><strong>Ownership</strong> √® il sistema di gestione memoria unico di Rust che garantisce sicurezza senza garbage collector. Ogni valore ha un solo proprietario alla volta.</p>

<pre><code>// ESEMPIO OWNERSHIP BASE
fn main() {
    // s1 √® il PROPRIETARIO della stringa "Rust"
    // La memoria viene allocata nell'heap
    let s1 = String::from("Rust");

    // MOVE: la propriet√† passa da s1 a s2
    // s1 NON √® pi√π valido dopo questa riga
    let s2 = s1;

    // ‚ùå println!("{}", s1); // ERRORE! s1 √® stato "mosso"

    // ‚úÖ s2 √® ora l'unico proprietario valido
    println!("s2 contiene: {}", s2);

    // Quando s2 esce dallo scope, la memoria viene automaticamente liberata
}

// SPIEGAZIONE DETTAGLIATA:
// 1. String::from() alloca memoria nell'heap per contenere "Rust"
// 2. s1 diventa proprietario: ha la responsabilit√† di liberare la memoria
// 3. let s2 = s1 TRASFERISCE (move) la propriet√† da s1 a s2
// 4. Rust invalida s1 per prevenire double-free (liberare memoria due volte)
// 5. Solo s2 pu√≤ ora accedere ai dati
// 6. Quando s2 esce dallo scope, Rust chiama automaticamente drop() per liberare memoria
</code></pre>

<h4>2. Borrowing - Prestare Riferimenti</h4>
<p><strong>Borrowing</strong> permette di usare un valore senza prenderne possesso, attraverso riferimenti (&). √à come "prestare" un libro senza trasferirne la propriet√†.</p>

<pre><code>// ESEMPIO BORROWING IMMUTABILE
fn main() {
    let s1 = String::from("Ownership");

    // &s1 crea un RIFERIMENTO IMMUTABILE (borrow)
    // s1 rimane proprietario, calcola_lunghezza "prende in prestito"
    let len = calcola_lunghezza(&s1);

    // ‚úÖ s1 √® ancora valido! Possiamo usarlo
    println!("La stringa '{}' ha lunghezza {}", s1, len);
}

// Funzione che PRENDE IN PRESTITO (borrow) una stringa
// &String significa "riferimento a String"
fn calcola_lunghezza(s: &String) -> usize {
    // Possiamo LEGGERE s, ma NON modificarlo
    s.len()  // Restituisce la lunghezza
    // Quando la funzione termina, il riferimento viene distrutto
    // MA la stringa originale rimane valida nel chiamante
}

// REGOLE BORROWING IMMUTABILE:
// ‚úÖ Puoi avere INFINITI riferimenti immutabili (&T) contemporaneamente
// ‚úÖ Puoi leggere i dati ma NON modificarli
// ‚úÖ Il proprietario originale mantiene la propriet√†
// ‚úÖ I dati non possono essere modificati finch√© esistono borrow immutabili
</code></pre>

<h4>3. Mutable Borrowing - Modificare Attraverso Riferimenti</h4>
<p><strong>Mutable borrowing</strong> (&mut) permette di modificare un valore preso in prestito, ma con regole rigide per evitare data races.</p>

<pre><code>// ESEMPIO MUTABLE BORROWING
fn main() {
    // IMPORTANTE: la variabile deve essere mut per permettere modifiche
    let mut testo = String::from("Ciao");

    // &mut testo crea un RIFERIMENTO MUTABILE
    // La funzione pu√≤ modificare testo attraverso questo riferimento
    modifica(&mut testo);

    // ‚úÖ testo √® stato modificato dalla funzione
    println!("Testo modificato: {}", testo);  // Output: "Ciao mondo!"
}

// Funzione che accetta un RIFERIMENTO MUTABILE
fn modifica(s: &mut String) {
    // push_str modifica la stringa originale
    s.push_str(" mondo!");

    // Altri esempi di modifica:
    // s.clear();           // Svuota la stringa
    // s.push('!');         // Aggiunge carattere
    // s.insert_str(0, "‚Üí"); // Inserisce all'inizio
}

// REGOLE MUTABLE BORROWING (FONDAMENTALI):
// 1. Puoi avere UN SOLO &mut riferimento alla volta
// 2. NON puoi avere &mut e & riferimenti contemporaneamente
// 3. Previene data races a compile-time
// 4. La variabile originale deve essere dichiarata mut
</code></pre>

<h4>4. Pattern Matching - Destrutturare e Gestire Casi</h4>
<p><strong>Pattern matching</strong> con <code>match</code> permette di gestire tutti i possibili casi in modo sicuro ed esaustivo.</p>

<pre><code>// DEFINIZIONE ENUM - Tipo che pu√≤ essere uno tra diversi valori
enum Risultato {
    // Variant con dati associati
    Ok(String),      // Caso successo: contiene messaggio
    Errore(i32),     // Caso errore: contiene codice
}

// ESEMPIO PATTERN MATCHING
fn main() {
    // Creiamo un Risultato di successo
    let r = Risultato::Ok("Operazione completata".to_string());

    // MATCH: controlliamo TUTTI i possibili casi
    match r {
        // Se √® Ok, estraiamo il messaggio nella variabile msg
        Risultato::Ok(msg) => {
            println!("‚úì Successo: {}", msg);
        }

        // Se √® Errore, estraiamo il codice nella variabile code
        Risultato::Errore(code) => {
            println!("‚úó Errore con codice: {}", code);
        }
    }
}

// PATTERN MATCHING AVANZATO
fn esempio_avanzato() {
    let numero = 42;

    match numero {
        0 => println!("Zero!"),
        1..=10 => println!("Da uno a dieci"),
        n if n % 2 == 0 => println!("{} √® pari", n),
        n if n % 2 == 1 => println!("{} √® dispari", n),
        _ => println!("Altro numero"),
    }
}
</code></pre>

<h4>5. Riepilogo Esempio Completo</h4>
<pre><code>// ESEMPIO CHE COMBINA TUTTI I CONCETTI

// Struct con lifetime
struct Libro<'a> {
    titolo: &'a str,
    autore: &'a str,
    pagine: u32,
}

impl<'a> Libro<'a> {
    fn nuovo(titolo: &'a str, autore: &'a str, pagine: u32) -> Self {
        Libro { titolo, autore, pagine }
    }

    fn info(&self) -> String {
        format!("{} di {} ({} pagine)", 
                self.titolo, self.autore, self.pagine)
    }
}

fn main() {
    // OWNERSHIP
    let titolo = String::from("Il Linguaggio Rust");
    let autore = String::from("Steve Klabnik");

    // BORROWING
    let libro = Libro::nuovo(&titolo, &autore, 552);

    println!("Libro: {}", libro.info());
}
</code></pre>
            </div>

            <div class="box box-exercises">
                <h3>‚úèÔ∏è Esercizi Pratici</h3>
                <ol>
    <li><strong>Ownership Base</strong>: Move, copy, clone strings.</li>
    <li><strong>Borrowing</strong>: Funzioni con riferimenti.</li>
    <li><strong>Mutable Reference</strong>: Modificare con &mut.</li>
    <li><strong>Lifetimes</strong>: Parametri lifetime.</li>
    <li><strong>Pattern Matching</strong>: Match Option e Result.</li>
    <li><strong>Challenge</strong>: Parser con pattern matching.</li>
</ol>
            </div>

            <div class="box box-troubleshooting">
                <h3>‚ö†Ô∏è Troubleshooting</h3>
                <h4>‚ùå "value used after move"</h4>
<p><strong>Causa:</strong> Variabile spostata, poi usata.</p>
<p><strong>Soluzione:</strong> Usa reference (&).</p>

<h4>‚ùå "cannot borrow as mutable more than once"</h4>
<p><strong>Causa:</strong> Pi√π &mut contemporanei.</p>
<p><strong>Soluzione:</strong> Un solo &mut alla volta.</p>
            </div>

            <nav class="lesson-nav">
                <a href="lesson-1-3.html">‚Üê Precedente</a>
                <a href="lesson-2-2.html">Successiva ‚Üí</a>
            </nav>
        </main>
    </div>

    <footer>
        <p>&copy; 2025 Corso Rust Linux Desktop | Creato con ‚ù§Ô∏è per la community Rust</p>
        <p><a href="https://www.rust-lang.org" target="_blank">Rust Programming Language</a> | <a href="https://gtk-rs.org" target="_blank">GTK-rs</a></p>
    </footer>

    <script src="script.js"></script>
</body>
</html>